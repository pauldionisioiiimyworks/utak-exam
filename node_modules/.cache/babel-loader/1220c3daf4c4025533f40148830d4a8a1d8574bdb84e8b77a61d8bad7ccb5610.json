{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreTransaction from './FirestoreTransaction';\nlet transactionId = 0;\n\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\nconst generateTransactionId = () => transactionId++;\nexport default class FirestoreTransactionHandler {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._pending = {};\n    this._firestore.emitter.addListener(this._firestore.eventNameForApp('firestore_transaction_event'), this._onTransactionEvent.bind(this));\n  }\n  _onTransactionEvent(event) {\n    switch (event.body.type) {\n      case 'update':\n        this._handleUpdate(event);\n        break;\n      case 'error':\n        this._handleError(event);\n        break;\n      case 'complete':\n        this._handleComplete(event);\n        break;\n    }\n  }\n  async _handleUpdate(event) {\n    const {\n      listenerId: id\n    } = event;\n\n    // abort if no longer exists js side\n    if (!this._pending[id]) {\n      return this._remove(id);\n    }\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    const {\n      updateFunction,\n      reject\n    } = meta;\n\n    // clear any saved state from previous transaction runs\n    transaction._prepare();\n    let finalError;\n    let updateFailed;\n    let pendingResult;\n    try {\n      const possiblePromise = updateFunction(transaction);\n\n      // validate user has returned a promise in their update function\n      if (!possiblePromise || !possiblePromise.then) {\n        throw new Error(\"firebase.firestore().runTransaction(*) 'updateFunction' must return a Promise.\");\n      }\n      pendingResult = await possiblePromise;\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    }\n\n    // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n    if (updateFailed || finalError) {\n      return reject(finalError);\n    }\n\n    // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n    transaction._pendingResult = pendingResult;\n\n    // send the buffered update/set/delete commands for native to process\n    return this._firestore.native.transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n\n  /**\n   * Reject the promise with a native error event\n   *\n   * @param event\n   * @private\n   */\n  _handleError(event) {\n    const {\n      listenerId: id,\n      body\n    } = event;\n    const {\n      error\n    } = body;\n    if (!this._pending[id]) {\n      return;\n    }\n    const {\n      meta\n    } = this._pending[id];\n    if (meta && error) {\n      const errorAndStack = NativeError.fromEvent(error, 'firestore', meta.stack);\n      meta.reject(errorAndStack);\n    }\n  }\n\n  /**\n   * Once the transaction has completed on native, resolve the promise with any\n   * pending results\n   *\n   * @param event\n   * @private\n   */\n  _handleComplete(event) {\n    const {\n      listenerId: id\n    } = event;\n    if (!this._pending[id]) {\n      return;\n    }\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    if (meta) {\n      meta.resolve(transaction._pendingResult);\n    }\n  }\n\n  /**\n   * Internally adds a transaction execution function to the queue\n   *\n   * @param updateFunction\n   * @returns {Promise<any>}\n   * @private\n   */\n  _add(updateFunction) {\n    const id = generateTransactionId();\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n')\n    };\n    this._pending[id] = {\n      meta,\n      transaction: new FirestoreTransaction(this._firestore, meta)\n    };\n    return new Promise((resolve, reject) => {\n      this._firestore.native.transactionBegin(id);\n      meta.resolve = result => {\n        this._remove(id);\n        resolve(result);\n      };\n      meta.reject = error => {\n        this._remove(id);\n        reject(error);\n      };\n    });\n  }\n\n  /**\n   * Internally removes the transaction once it has resolved\n   * or rejected\n   *\n   * @param id\n   * @private\n   */\n  _remove(id) {\n    this._firestore.native.transactionDispose(id);\n    delete this._pending[id];\n  }\n}","map":{"version":3,"names":["NativeError","FirestoreTransaction","transactionId","generateTransactionId","FirestoreTransactionHandler","constructor","firestore","_firestore","_pending","emitter","addListener","eventNameForApp","_onTransactionEvent","bind","event","body","type","_handleUpdate","_handleError","_handleComplete","listenerId","id","_remove","meta","transaction","updateFunction","reject","_prepare","finalError","updateFailed","pendingResult","possiblePromise","then","Error","exception","_pendingResult","native","transactionApplyBuffer","_commandBuffer","error","errorAndStack","fromEvent","stack","resolve","_add","split","slice","join","Promise","transactionBegin","result","transactionDispose"],"sources":["/Users/pauldionisio/Documents/CS/utak/utak-exam-app/node_modules/@react-native-firebase/firestore/lib/FirestoreTransactionHandler.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreTransaction from './FirestoreTransaction';\n\nlet transactionId = 0;\n\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\nconst generateTransactionId = () => transactionId++;\n\nexport default class FirestoreTransactionHandler {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._pending = {};\n    this._firestore.emitter.addListener(\n      this._firestore.eventNameForApp('firestore_transaction_event'),\n      this._onTransactionEvent.bind(this),\n    );\n  }\n\n  _onTransactionEvent(event) {\n    switch (event.body.type) {\n      case 'update':\n        this._handleUpdate(event);\n        break;\n      case 'error':\n        this._handleError(event);\n        break;\n      case 'complete':\n        this._handleComplete(event);\n        break;\n    }\n  }\n\n  async _handleUpdate(event) {\n    const { listenerId: id } = event;\n\n    // abort if no longer exists js side\n    if (!this._pending[id]) {\n      return this._remove(id);\n    }\n\n    const { meta, transaction } = this._pending[id];\n    const { updateFunction, reject } = meta;\n\n    // clear any saved state from previous transaction runs\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult;\n\n    try {\n      const possiblePromise = updateFunction(transaction);\n\n      // validate user has returned a promise in their update function\n      if (!possiblePromise || !possiblePromise.then) {\n        throw new Error(\n          \"firebase.firestore().runTransaction(*) 'updateFunction' must return a Promise.\",\n        );\n      }\n\n      pendingResult = await possiblePromise;\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    }\n\n    // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n    if (updateFailed || finalError) {\n      return reject(finalError);\n    }\n\n    // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n    transaction._pendingResult = pendingResult;\n\n    // send the buffered update/set/delete commands for native to process\n    return this._firestore.native.transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n\n  /**\n   * Reject the promise with a native error event\n   *\n   * @param event\n   * @private\n   */\n  _handleError(event) {\n    const { listenerId: id, body } = event;\n    const { error } = body;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const { meta } = this._pending[id];\n\n    if (meta && error) {\n      const errorAndStack = NativeError.fromEvent(error, 'firestore', meta.stack);\n      meta.reject(errorAndStack);\n    }\n  }\n\n  /**\n   * Once the transaction has completed on native, resolve the promise with any\n   * pending results\n   *\n   * @param event\n   * @private\n   */\n  _handleComplete(event) {\n    const { listenerId: id } = event;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const { meta, transaction } = this._pending[id];\n    if (meta) {\n      meta.resolve(transaction._pendingResult);\n    }\n  }\n\n  /**\n   * Internally adds a transaction execution function to the queue\n   *\n   * @param updateFunction\n   * @returns {Promise<any>}\n   * @private\n   */\n  _add(updateFunction) {\n    const id = generateTransactionId();\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n'),\n    };\n\n    this._pending[id] = {\n      meta,\n      transaction: new FirestoreTransaction(this._firestore, meta),\n    };\n\n    return new Promise((resolve, reject) => {\n      this._firestore.native.transactionBegin(id);\n\n      meta.resolve = result => {\n        this._remove(id);\n        resolve(result);\n      };\n\n      meta.reject = error => {\n        this._remove(id);\n        reject(error);\n      };\n    });\n  }\n\n  /**\n   * Internally removes the transaction once it has resolved\n   * or rejected\n   *\n   * @param id\n   * @private\n   */\n  _remove(id) {\n    this._firestore.native.transactionDispose(id);\n    delete this._pending[id];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}