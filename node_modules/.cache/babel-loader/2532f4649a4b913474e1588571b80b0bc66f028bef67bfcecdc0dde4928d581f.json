{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { hasOwnProperty, isArray, isBoolean, isFunction, isObject, isString, isUndefined } from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\nexport function extractFieldPathData(data, segments) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n  const pathValue = data[segments[0]];\n  if (segments.length === 1) {\n    return pathValue;\n  }\n  return extractFieldPathData(pathValue, segments.slice(1));\n}\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error('the update arguments must be either a single object argument, or equal numbers of key/value pairs.');\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n  if (isUndefined(options)) {\n    return out;\n  }\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n    out.merge = options.merge;\n  }\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n    out.mergeFields = [];\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(`'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`);\n      }\n      let path = field;\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n  return {\n    snapshotListenOptions,\n    callback,\n    onNext,\n    onError\n  };\n}","map":{"version":3,"names":["hasOwnProperty","isArray","isBoolean","isFunction","isObject","isString","isUndefined","FirestoreFieldPath","fromDotSeparatedString","extractFieldPathData","data","segments","undefined","pathValue","length","slice","parseUpdateArgs","args","Error","i","key","value","_toPath","parseSetOptions","options","out","merge","mergeFields","field","path","e","message","push","isPartialObserver","input","next","error","complete","parseSnapshotArgs","NOOP","snapshotListenOptions","callback","onError","onNext","observer","bind","includeMetadataChanges"],"sources":["/Users/pauldionisio/Documents/CS/utak/utak-exam-app/node_modules/@react-native-firebase/firestore/lib/utils/index.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  hasOwnProperty,\n  isArray,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\n\nexport function extractFieldPathData(data, segments) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segments[0]];\n\n  if (segments.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segments.slice(1));\n}\n\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(\n      'the update arguments must be either a single object argument, or equal numbers of key/value pairs.',\n    );\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = options.merge;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\n          `'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`,\n        );\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges =\n      args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return { snapshotListenOptions, callback, onNext, onError };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}