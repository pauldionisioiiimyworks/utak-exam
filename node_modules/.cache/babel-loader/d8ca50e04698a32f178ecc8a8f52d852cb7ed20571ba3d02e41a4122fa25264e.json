{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { DOCUMENT_ID } from './FirestoreFieldPath';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nexport const OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN'\n};\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true\n};\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n\n    // Pulled out of function to preserve their state\n    this.hasInequality = false;\n    this.hasNotEqual = false;\n    this.hasArrayContains = false;\n    this.hasArrayContainsAny = false;\n    this.hasIn = false;\n    this.hasNotIn = false;\n  }\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n  get filters() {\n    return this._filters.map(f => ({\n      ...f,\n      fieldPath: f.fieldPath instanceof FirestoreFieldPath ? f.fieldPath._toArray() : f.fieldPath\n    }));\n  }\n  get orders() {\n    return this._orders.map(f => ({\n      ...f,\n      fieldPath: f.fieldPath instanceof FirestoreFieldPath ? f.fieldPath._toArray() : f.fieldPath\n    }));\n  }\n  get options() {\n    const options = {};\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n    return options;\n  }\n  get type() {\n    return this._type;\n  }\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error('firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause');\n      }\n    }\n  }\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n  isNotEqualOperator(operator) {\n    return OPERATORS[operator] === 'NOT_EQUAL';\n  }\n  isInOperator(operator) {\n    return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' || OPERATORS[operator] === 'NOT_IN';\n  }\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true)\n    };\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n  filterWhere(filter) {\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n  validateWhere() {\n    if (this._filters.length > 0) {\n      this._filterCheck(this._filters);\n    }\n  }\n  _filterCheck(filters) {\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (filter.queries) {\n        // Recursively check sub-queries for Filters\n        this._filterCheck(filter.queries);\n        // If it is a Filter query, skip the rest of the loop\n        continue;\n      }\n\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n      if (filter.operator === OPERATORS['!=']) {\n        if (this.hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        }\n        //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n        this.hasNotEqual = true;\n      }\n\n      // Set the first inequality\n      if (!this.hasInequality) {\n        this.hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && this.hasInequality) {\n        if (this.hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(`Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${this.hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`);\n        }\n      }\n    }\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (this.hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        this.hasArrayContains = true;\n      }\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (this.hasArrayContainsAny) {\n          throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n        }\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\");\n        }\n        this.hasArrayContainsAny = true;\n      }\n      if (filter.operator === OPERATORS.in) {\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n        this.hasIn = true;\n      }\n      if (filter.operator === OPERATORS['not-in']) {\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n        if (this.hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\");\n        }\n        if (this.hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n        if (this.hasArrayContainsAny) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\");\n        }\n        this.hasNotIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath,\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n    };\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n  validateOrderBy() {\n    this._validateOrderByCheck(this._filters);\n  }\n  _validateOrderByCheck(filters) {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath._toPath());\n      const set = new Set(orders);\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (filter.queries) {\n        // Recursively check sub-queries for Filters\n        this._validateOrderByCheck(filter.queries);\n        // If it is a Filter query, skip the rest of the loop\n        continue;\n      }\n      const filterFieldPath = filter.fieldPath._toPath();\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath._toPath()) {\n            throw new Error(`Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`);\n          }\n        }\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n        }\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath._toPath()) {\n            throw new Error(`Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `);\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["isNumber","FirestoreFieldPath","DOCUMENT_ID","buildNativeArray","generateNativeData","OPERATORS","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","NOT_EQUAL","DIRECTIONS","asc","desc","FirestoreQueryModifiers","constructor","_limit","undefined","_limitToLast","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","hasInequality","hasNotEqual","hasArrayContains","hasArrayContainsAny","hasIn","hasNotIn","_copy","newInstance","filters","map","f","fieldPath","_toArray","orders","options","limit","limitToLast","startAt","startAfter","endAt","endBefore","type","setFieldsCursor","cursor","fields","hasStart","hasEnd","asCollectionGroupQuery","isCollectionGroupQuery","isValidLimit","Math","floor","isValidLimitToLast","validatelimitToLast","length","Error","isValidOperator","operator","isEqualOperator","isNotEqualOperator","isInOperator","where","opStr","value","filter","concat","filterWhere","validateWhere","_filterCheck","i","queries","_toPath","isValidDirection","directionStr","toLowerCase","orderBy","order","direction","validateOrderBy","_validateOrderByCheck","$","set","Set","size","filterFieldPath","k","orderFieldPath"],"sources":["/Users/pauldionisio/Documents/CS/utak/utak-exam-app/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { DOCUMENT_ID } from './FirestoreFieldPath';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\n\nexport const OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n\n    // Pulled out of function to preserve their state\n    this.hasInequality = false;\n    this.hasNotEqual = false;\n    this.hasArrayContains = false;\n    this.hasArrayContainsAny = false;\n    this.hasIn = false;\n    this.hasNotIn = false;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({\n      ...f,\n      fieldPath: f.fieldPath instanceof FirestoreFieldPath ? f.fieldPath._toArray() : f.fieldPath,\n    }));\n  }\n\n  get orders() {\n    return this._orders.map(f => ({\n      ...f,\n      fieldPath: f.fieldPath instanceof FirestoreFieldPath ? f.fieldPath._toArray() : f.fieldPath,\n    }));\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error(\n          'firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause',\n        );\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isNotEqualOperator(operator) {\n    return OPERATORS[operator] === 'NOT_EQUAL';\n  }\n\n  isInOperator(operator) {\n    return (\n      OPERATORS[operator] === 'IN' ||\n      OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' ||\n      OPERATORS[operator] === 'NOT_IN'\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  filterWhere(filter) {\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    if (this._filters.length > 0) {\n      this._filterCheck(this._filters);\n    }\n  }\n\n  _filterCheck(filters) {\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n\n      if (filter.queries) {\n        // Recursively check sub-queries for Filters\n        this._filterCheck(filter.queries);\n        // If it is a Filter query, skip the rest of the loop\n        continue;\n      }\n\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      if (filter.operator === OPERATORS['!=']) {\n        if (this.hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        }\n        //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n        this.hasNotEqual = true;\n      }\n\n      // Set the first inequality\n      if (!this.hasInequality) {\n        this.hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && this.hasInequality) {\n        if (this.hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${this.hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (this.hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        this.hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (this.hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (this.hasNotIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\",\n          );\n        }\n\n        this.hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n\n        this.hasIn = true;\n      }\n\n      if (filter.operator === OPERATORS['not-in']) {\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n\n        if (this.hasNotEqual) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\",\n          );\n        }\n\n        if (this.hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n\n        if (this.hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        this.hasNotIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath,\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    this._validateOrderByCheck(this._filters);\n  }\n\n  _validateOrderByCheck(filters) {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath._toPath());\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n\n      if (filter.queries) {\n        // Recursively check sub-queries for Filters\n        this._validateOrderByCheck(filter.queries);\n        // If it is a Filter query, skip the rest of the loop\n        continue;\n      }\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath._toPath()) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath._toPath()) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}