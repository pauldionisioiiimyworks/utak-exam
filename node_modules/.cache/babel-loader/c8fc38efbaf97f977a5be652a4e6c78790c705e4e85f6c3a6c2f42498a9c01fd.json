{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isArray, isNull, isObject, isString, isUndefined } from '@react-native-firebase/app/lib/common';\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport { FirestoreAggregateQuery } from './FirestoreAggregate';\nimport FirestoreDocumentSnapshot from './FirestoreDocumentSnapshot';\nimport FirestoreFieldPath, { fromDotSeparatedString } from './FirestoreFieldPath';\nimport FirestoreQuerySnapshot from './FirestoreQuerySnapshot';\nimport { parseSnapshotArgs } from './utils';\nimport { _Filter, generateFilters } from './FirestoreFilter';\nlet _id = 0;\nexport default class FirestoreQuery {\n  constructor(firestore, collectionPath, modifiers, queryName) {\n    this._firestore = firestore;\n    this._collectionPath = collectionPath;\n    this._modifiers = modifiers;\n    this._queryName = queryName;\n  }\n  get firestore() {\n    return this._firestore;\n  }\n  _handleQueryCursor(cursor, docOrField, fields) {\n    const modifiers = this._modifiers._copy();\n    if (isUndefined(docOrField)) {\n      throw new Error(`firebase.firestore().collection().${cursor}(*) Expected a DocumentSnapshot or list of field values but got undefined.`);\n    }\n\n    // Handles cases where the first arg is a DocumentSnapshot\n    if (docOrField instanceof FirestoreDocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new Error(`firebase.firestore().collection().${cursor}(*) Too many arguments provided. Expected DocumentSnapshot or list of field values.`);\n      }\n      const documentSnapshot = docOrField;\n      if (!documentSnapshot.exists) {\n        throw new Error(`firebase.firestore().collection().${cursor}(*) Can't use a DocumentSnapshot that doesn't exist.`);\n      }\n      const currentOrders = modifiers.orders;\n      const values = [];\n      for (let i = 0; i < currentOrders.length; i++) {\n        const order = currentOrders[i];\n        //skip if fieldPath is '__name__'\n        if (order.fieldPath === '__name__') {\n          continue;\n        }\n        const value = documentSnapshot.get(order.fieldPath);\n        if (value === undefined) {\n          throw new Error(`firebase.firestore().collection().${cursor}(*) You are trying to start or end a query using a document for which the field '${order.fieldPath}' (used as the orderBy) does not exist.`);\n        }\n        values.push(value);\n      }\n\n      // Based on https://github.com/invertase/react-native-firebase/issues/2854#issuecomment-552986650\n      if (modifiers._orders.length) {\n        const lastOrder = modifiers._orders[modifiers._orders.length - 1];\n        //push '__name__' field only if not present already\n        if (lastOrder.fieldPath !== '__name__') {\n          modifiers._orders.push({\n            fieldPath: '__name__',\n            direction: lastOrder.direction\n          });\n        }\n      } else {\n        modifiers._orders.push({\n          fieldPath: '__name__',\n          direction: 'ASCENDING'\n        });\n      }\n      if (this._modifiers.isCollectionGroupQuery()) {\n        values.push(documentSnapshot.ref.path);\n      } else {\n        values.push(documentSnapshot.id);\n      }\n      return modifiers.setFieldsCursor(cursor, values);\n    }\n\n    /**\n     * Assumes list of field values to query by. Orders must be of equal length.\n     */\n\n    const allFields = [docOrField].concat(fields);\n    if (allFields.length > modifiers.orders.length) {\n      throw new Error(`firebase.firestore().collection().${cursor}(*) Too many arguments provided. The number of arguments must be less than or equal to the number of orderBy() clauses.`);\n    }\n    return modifiers.setFieldsCursor(cursor, allFields);\n  }\n  count() {\n    return new FirestoreAggregateQuery(this._firestore, this, this._collectionPath, this._modifiers);\n  }\n  countFromServer() {\n    return this.count();\n  }\n  endAt(docOrField, ...fields) {\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('endAt', docOrField, fields), this._queryName);\n  }\n  endBefore(docOrField, ...fields) {\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('endBefore', docOrField, fields), this._queryName);\n  }\n  get(options) {\n    if (!isUndefined(options) && !isObject(options)) {\n      throw new Error(\"firebase.firestore().collection().get(*) 'options' must be an object is provided.\");\n    }\n    if (options && options.source && options.source !== 'default' && options.source !== 'server' && options.source !== 'cache') {\n      throw new Error(\"firebase.firestore().collection().get(*) 'options' GetOptions.source must be one of 'default', 'server' or 'cache'.\");\n    }\n    if (!isUndefined(this._queryName)) {\n      return this._firestore.native.namedQueryGet(this._queryName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, options).then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n    }\n    this._modifiers.validatelimitToLast();\n    return this._firestore.native.collectionGet(this._collectionPath.relativeName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, options).then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n  }\n  isEqual(other) {\n    if (!(other instanceof FirestoreQuery)) {\n      throw new Error(\"firebase.firestore().collection().isEqual(*) 'other' expected a Query instance.\");\n    }\n\n    // Carry out lightweight checks first\n    if (this.firestore.app.name !== other.firestore.app.name || this._modifiers.type !== other._modifiers.type || this._modifiers.filters.length !== other._modifiers.filters.length || this._modifiers.orders.length !== other._modifiers.orders.length || this._collectionPath.relativeName !== other._collectionPath.relativeName || Object.keys(this._modifiers.options).length !== Object.keys(other._modifiers.options).length) {\n      return false;\n    }\n\n    // Carry out potentially expensive checks\n    // noinspection RedundantIfStatementJS\n    if (JSON.stringify(this._modifiers.filters) !== JSON.stringify(other._modifiers.filters) || JSON.stringify(this._modifiers.orders) !== JSON.stringify(other._modifiers.orders) || JSON.stringify(this._modifiers.options) !== JSON.stringify(other._modifiers.options)) {\n      return false;\n    }\n    return true;\n  }\n  limit(limit) {\n    if (this._modifiers.isValidLimit(limit)) {\n      throw new Error(\"firebase.firestore().collection().limit(*) 'limit' must be a positive integer value.\");\n    }\n    const modifiers = this._modifiers._copy().limit(limit);\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n  limitToLast(limitToLast) {\n    if (this._modifiers.isValidLimitToLast(limitToLast)) {\n      throw new Error(\"firebase.firestore().collection().limitToLast(*) 'limitToLast' must be a positive integer value.\");\n    }\n    const modifiers = this._modifiers._copy().limitToLast(limitToLast);\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n  onSnapshot(...args) {\n    let snapshotListenOptions;\n    let callback;\n    let onNext;\n    let onError;\n    this._modifiers.validatelimitToLast();\n    try {\n      const options = parseSnapshotArgs(args);\n      snapshotListenOptions = options.snapshotListenOptions;\n      callback = options.callback;\n      onNext = options.onNext;\n      onError = options.onError;\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().onSnapshot(*) ${e.message}`);\n    }\n    function handleSuccess(querySnapshot) {\n      callback(querySnapshot, null);\n      onNext(querySnapshot);\n    }\n    function handleError(error) {\n      callback(null, error);\n      onError(error);\n    }\n    const listenerId = _id++;\n    const onSnapshotSubscription = this._firestore.emitter.addListener(this._firestore.eventNameForApp(`firestore_collection_sync_event:${listenerId}`), event => {\n      if (event.body.error) {\n        handleError(NativeError.fromEvent(event.body.error, 'firestore'));\n      } else {\n        const querySnapshot = new FirestoreQuerySnapshot(this._firestore, this, event.body.snapshot);\n        handleSuccess(querySnapshot);\n      }\n    });\n    const unsubscribe = () => {\n      onSnapshotSubscription.remove();\n      this._firestore.native.collectionOffSnapshot(listenerId);\n    };\n    if (!isUndefined(this._queryName)) {\n      this._firestore.native.namedQueryOnSnapshot(this._queryName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, listenerId, snapshotListenOptions);\n    } else {\n      this._firestore.native.collectionOnSnapshot(this._collectionPath.relativeName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, listenerId, snapshotListenOptions);\n    }\n    return unsubscribe;\n  }\n  orderBy(fieldPath, directionStr) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\"firebase.firestore().collection().orderBy(*) 'fieldPath' must be a string or instance of FieldPath.\");\n    }\n    let path;\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().orderBy(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n    if (!isUndefined(directionStr) && !this._modifiers.isValidDirection(directionStr)) {\n      throw new Error(\"firebase.firestore().collection().orderBy(_, *) 'directionStr' must be one of 'asc' or 'desc'.\");\n    }\n    if (this._modifiers.hasStart()) {\n      throw new Error('firebase.firestore().collection().orderBy() Invalid query. You must not call startAt() or startAfter() before calling orderBy().');\n    }\n    if (this._modifiers.hasEnd()) {\n      throw new Error('firebase.firestore().collection().orderBy() Invalid query. You must not call endAt() or endBefore() before calling orderBy().');\n    }\n    const modifiers = this._modifiers._copy().orderBy(path, directionStr);\n    try {\n      modifiers.validateOrderBy();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().orderBy() ${e.message}`);\n    }\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n  startAfter(docOrField, ...fields) {\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('startAfter', docOrField, fields), this._queryName);\n  }\n  startAt(docOrField, ...fields) {\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('startAt', docOrField, fields), this._queryName);\n  }\n  where(fieldPathOrFilter, opStr, value) {\n    if (!isString(fieldPathOrFilter) && !(fieldPathOrFilter instanceof FirestoreFieldPath) && !(fieldPathOrFilter instanceof _Filter)) {\n      throw new Error(\"firebase.firestore().collection().where(*) 'fieldPath' must be a string, instance of FieldPath or instance of Filter.\");\n    }\n    let modifiers;\n    if (fieldPathOrFilter instanceof _Filter && fieldPathOrFilter.queries) {\n      //AND or OR filter\n      const filters = generateFilters(fieldPathOrFilter, this._modifiers);\n      modifiers = this._modifiers._copy().filterWhere(filters);\n    } else {\n      if (fieldPathOrFilter instanceof _Filter) {\n        // Standard Filter. Usual path.\n        opStr = fieldPathOrFilter.operator;\n        value = fieldPathOrFilter.value;\n        fieldPathOrFilter = fieldPathOrFilter.fieldPath;\n      }\n      let path;\n      if (isString(fieldPathOrFilter)) {\n        try {\n          path = fromDotSeparatedString(fieldPathOrFilter);\n        } catch (e) {\n          throw new Error(`firebase.firestore().collection().where(*) 'fieldPath' ${e.message}.`);\n        }\n      } else {\n        path = fieldPathOrFilter;\n      }\n      if (!this._modifiers.isValidOperator(opStr)) {\n        throw new Error(\"firebase.firestore().collection().where(_, *) 'opStr' is invalid. Expected one of '==', '>', '>=', '<', '<=', '!=', 'array-contains', 'not-in', 'array-contains-any' or 'in'.\");\n      }\n      if (isUndefined(value)) {\n        throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' argument expected.\");\n      }\n      if (isNull(value) && !this._modifiers.isEqualOperator(opStr) && !this._modifiers.isNotEqualOperator(opStr)) {\n        throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' is invalid. You can only perform equals comparisons on null\");\n      }\n      if (this._modifiers.isInOperator(opStr)) {\n        if (!isArray(value) || !value.length) {\n          throw new Error(`firebase.firestore().collection().where(_, _, *) 'value' is invalid. A non-empty array is required for '${opStr}' filters.`);\n        }\n        if (value.length > 30) {\n          throw new Error(`firebase.firestore().collection().where(_, _, *) 'value' is invalid. '${opStr}' filters support a maximum of 30 elements in the value array.`);\n        }\n      }\n      modifiers = this._modifiers._copy().where(path, opStr, value);\n    }\n    try {\n      modifiers.validateWhere();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().where() ${e.message}`);\n    }\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n}","map":{"version":3,"names":["isArray","isNull","isObject","isString","isUndefined","NativeError","FirestoreAggregateQuery","FirestoreDocumentSnapshot","FirestoreFieldPath","fromDotSeparatedString","FirestoreQuerySnapshot","parseSnapshotArgs","_Filter","generateFilters","_id","FirestoreQuery","constructor","firestore","collectionPath","modifiers","queryName","_firestore","_collectionPath","_modifiers","_queryName","_handleQueryCursor","cursor","docOrField","fields","_copy","Error","length","documentSnapshot","exists","currentOrders","orders","values","i","order","fieldPath","value","get","undefined","push","_orders","lastOrder","direction","isCollectionGroupQuery","ref","path","id","setFieldsCursor","allFields","concat","count","countFromServer","endAt","endBefore","options","source","native","namedQueryGet","type","filters","then","data","validatelimitToLast","collectionGet","relativeName","isEqual","other","app","name","Object","keys","JSON","stringify","limit","isValidLimit","limitToLast","isValidLimitToLast","onSnapshot","args","snapshotListenOptions","callback","onNext","onError","e","message","handleSuccess","querySnapshot","handleError","error","listenerId","onSnapshotSubscription","emitter","addListener","eventNameForApp","event","body","fromEvent","snapshot","unsubscribe","remove","collectionOffSnapshot","namedQueryOnSnapshot","collectionOnSnapshot","orderBy","directionStr","isValidDirection","hasStart","hasEnd","validateOrderBy","startAfter","startAt","where","fieldPathOrFilter","opStr","queries","filterWhere","operator","isValidOperator","isEqualOperator","isNotEqualOperator","isInOperator","validateWhere"],"sources":["/Users/pauldionisio/Documents/CS/utak/utak-exam-app/node_modules/@react-native-firebase/firestore/lib/FirestoreQuery.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  isArray,\n  isNull,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport { FirestoreAggregateQuery } from './FirestoreAggregate';\nimport FirestoreDocumentSnapshot from './FirestoreDocumentSnapshot';\nimport FirestoreFieldPath, { fromDotSeparatedString } from './FirestoreFieldPath';\nimport FirestoreQuerySnapshot from './FirestoreQuerySnapshot';\nimport { parseSnapshotArgs } from './utils';\nimport { _Filter, generateFilters } from './FirestoreFilter';\n\nlet _id = 0;\n\nexport default class FirestoreQuery {\n  constructor(firestore, collectionPath, modifiers, queryName) {\n    this._firestore = firestore;\n    this._collectionPath = collectionPath;\n    this._modifiers = modifiers;\n    this._queryName = queryName;\n  }\n\n  get firestore() {\n    return this._firestore;\n  }\n\n  _handleQueryCursor(cursor, docOrField, fields) {\n    const modifiers = this._modifiers._copy();\n\n    if (isUndefined(docOrField)) {\n      throw new Error(\n        `firebase.firestore().collection().${cursor}(*) Expected a DocumentSnapshot or list of field values but got undefined.`,\n      );\n    }\n\n    // Handles cases where the first arg is a DocumentSnapshot\n    if (docOrField instanceof FirestoreDocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new Error(\n          `firebase.firestore().collection().${cursor}(*) Too many arguments provided. Expected DocumentSnapshot or list of field values.`,\n        );\n      }\n\n      const documentSnapshot = docOrField;\n\n      if (!documentSnapshot.exists) {\n        throw new Error(\n          `firebase.firestore().collection().${cursor}(*) Can't use a DocumentSnapshot that doesn't exist.`,\n        );\n      }\n\n      const currentOrders = modifiers.orders;\n\n      const values = [];\n\n      for (let i = 0; i < currentOrders.length; i++) {\n        const order = currentOrders[i];\n        //skip if fieldPath is '__name__'\n        if (order.fieldPath === '__name__') {\n          continue;\n        }\n\n        const value = documentSnapshot.get(order.fieldPath);\n\n        if (value === undefined) {\n          throw new Error(\n            `firebase.firestore().collection().${cursor}(*) You are trying to start or end a query using a document for which the field '${order.fieldPath}' (used as the orderBy) does not exist.`,\n          );\n        }\n\n        values.push(value);\n      }\n\n      // Based on https://github.com/invertase/react-native-firebase/issues/2854#issuecomment-552986650\n      if (modifiers._orders.length) {\n        const lastOrder = modifiers._orders[modifiers._orders.length - 1];\n        //push '__name__' field only if not present already\n        if (lastOrder.fieldPath !== '__name__') {\n          modifiers._orders.push({\n            fieldPath: '__name__',\n            direction: lastOrder.direction,\n          });\n        }\n      } else {\n        modifiers._orders.push({\n          fieldPath: '__name__',\n          direction: 'ASCENDING',\n        });\n      }\n\n      if (this._modifiers.isCollectionGroupQuery()) {\n        values.push(documentSnapshot.ref.path);\n      } else {\n        values.push(documentSnapshot.id);\n      }\n\n      return modifiers.setFieldsCursor(cursor, values);\n    }\n\n    /**\n     * Assumes list of field values to query by. Orders must be of equal length.\n     */\n\n    const allFields = [docOrField].concat(fields);\n\n    if (allFields.length > modifiers.orders.length) {\n      throw new Error(\n        `firebase.firestore().collection().${cursor}(*) Too many arguments provided. The number of arguments must be less than or equal to the number of orderBy() clauses.`,\n      );\n    }\n\n    return modifiers.setFieldsCursor(cursor, allFields);\n  }\n\n  count() {\n    return new FirestoreAggregateQuery(\n      this._firestore,\n      this,\n      this._collectionPath,\n      this._modifiers,\n    );\n  }\n\n  countFromServer() {\n    return this.count();\n  }\n\n  endAt(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('endAt', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  endBefore(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('endBefore', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  get(options) {\n    if (!isUndefined(options) && !isObject(options)) {\n      throw new Error(\n        \"firebase.firestore().collection().get(*) 'options' must be an object is provided.\",\n      );\n    }\n\n    if (\n      options &&\n      options.source &&\n      options.source !== 'default' &&\n      options.source !== 'server' &&\n      options.source !== 'cache'\n    ) {\n      throw new Error(\n        \"firebase.firestore().collection().get(*) 'options' GetOptions.source must be one of 'default', 'server' or 'cache'.\",\n      );\n    }\n\n    if (!isUndefined(this._queryName)) {\n      return this._firestore.native\n        .namedQueryGet(\n          this._queryName,\n          this._modifiers.type,\n          this._modifiers.filters,\n          this._modifiers.orders,\n          this._modifiers.options,\n          options,\n        )\n        .then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n    }\n\n    this._modifiers.validatelimitToLast();\n\n    return this._firestore.native\n      .collectionGet(\n        this._collectionPath.relativeName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        options,\n      )\n      .then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n  }\n\n  isEqual(other) {\n    if (!(other instanceof FirestoreQuery)) {\n      throw new Error(\n        \"firebase.firestore().collection().isEqual(*) 'other' expected a Query instance.\",\n      );\n    }\n\n    // Carry out lightweight checks first\n    if (\n      this.firestore.app.name !== other.firestore.app.name ||\n      this._modifiers.type !== other._modifiers.type ||\n      this._modifiers.filters.length !== other._modifiers.filters.length ||\n      this._modifiers.orders.length !== other._modifiers.orders.length ||\n      this._collectionPath.relativeName !== other._collectionPath.relativeName ||\n      Object.keys(this._modifiers.options).length !== Object.keys(other._modifiers.options).length\n    ) {\n      return false;\n    }\n\n    // Carry out potentially expensive checks\n    // noinspection RedundantIfStatementJS\n    if (\n      JSON.stringify(this._modifiers.filters) !== JSON.stringify(other._modifiers.filters) ||\n      JSON.stringify(this._modifiers.orders) !== JSON.stringify(other._modifiers.orders) ||\n      JSON.stringify(this._modifiers.options) !== JSON.stringify(other._modifiers.options)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  limit(limit) {\n    if (this._modifiers.isValidLimit(limit)) {\n      throw new Error(\n        \"firebase.firestore().collection().limit(*) 'limit' must be a positive integer value.\",\n      );\n    }\n\n    const modifiers = this._modifiers._copy().limit(limit);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  limitToLast(limitToLast) {\n    if (this._modifiers.isValidLimitToLast(limitToLast)) {\n      throw new Error(\n        \"firebase.firestore().collection().limitToLast(*) 'limitToLast' must be a positive integer value.\",\n      );\n    }\n\n    const modifiers = this._modifiers._copy().limitToLast(limitToLast);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  onSnapshot(...args) {\n    let snapshotListenOptions;\n    let callback;\n    let onNext;\n    let onError;\n\n    this._modifiers.validatelimitToLast();\n\n    try {\n      const options = parseSnapshotArgs(args);\n      snapshotListenOptions = options.snapshotListenOptions;\n      callback = options.callback;\n      onNext = options.onNext;\n      onError = options.onError;\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().onSnapshot(*) ${e.message}`);\n    }\n\n    function handleSuccess(querySnapshot) {\n      callback(querySnapshot, null);\n      onNext(querySnapshot);\n    }\n\n    function handleError(error) {\n      callback(null, error);\n      onError(error);\n    }\n\n    const listenerId = _id++;\n\n    const onSnapshotSubscription = this._firestore.emitter.addListener(\n      this._firestore.eventNameForApp(`firestore_collection_sync_event:${listenerId}`),\n      event => {\n        if (event.body.error) {\n          handleError(NativeError.fromEvent(event.body.error, 'firestore'));\n        } else {\n          const querySnapshot = new FirestoreQuerySnapshot(\n            this._firestore,\n            this,\n            event.body.snapshot,\n          );\n          handleSuccess(querySnapshot);\n        }\n      },\n    );\n\n    const unsubscribe = () => {\n      onSnapshotSubscription.remove();\n      this._firestore.native.collectionOffSnapshot(listenerId);\n    };\n\n    if (!isUndefined(this._queryName)) {\n      this._firestore.native.namedQueryOnSnapshot(\n        this._queryName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        listenerId,\n        snapshotListenOptions,\n      );\n    } else {\n      this._firestore.native.collectionOnSnapshot(\n        this._collectionPath.relativeName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        listenerId,\n        snapshotListenOptions,\n      );\n    }\n\n    return unsubscribe;\n  }\n\n  orderBy(fieldPath, directionStr) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\n        \"firebase.firestore().collection().orderBy(*) 'fieldPath' must be a string or instance of FieldPath.\",\n      );\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().orderBy(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!isUndefined(directionStr) && !this._modifiers.isValidDirection(directionStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().orderBy(_, *) 'directionStr' must be one of 'asc' or 'desc'.\",\n      );\n    }\n\n    if (this._modifiers.hasStart()) {\n      throw new Error(\n        'firebase.firestore().collection().orderBy() Invalid query. You must not call startAt() or startAfter() before calling orderBy().',\n      );\n    }\n\n    if (this._modifiers.hasEnd()) {\n      throw new Error(\n        'firebase.firestore().collection().orderBy() Invalid query. You must not call endAt() or endBefore() before calling orderBy().',\n      );\n    }\n\n    const modifiers = this._modifiers._copy().orderBy(path, directionStr);\n\n    try {\n      modifiers.validateOrderBy();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().orderBy() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  startAfter(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('startAfter', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  startAt(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('startAt', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  where(fieldPathOrFilter, opStr, value) {\n    if (\n      !isString(fieldPathOrFilter) &&\n      !(fieldPathOrFilter instanceof FirestoreFieldPath) &&\n      !(fieldPathOrFilter instanceof _Filter)\n    ) {\n      throw new Error(\n        \"firebase.firestore().collection().where(*) 'fieldPath' must be a string, instance of FieldPath or instance of Filter.\",\n      );\n    }\n\n    let modifiers;\n    if (fieldPathOrFilter instanceof _Filter && fieldPathOrFilter.queries) {\n      //AND or OR filter\n      const filters = generateFilters(fieldPathOrFilter, this._modifiers);\n      modifiers = this._modifiers._copy().filterWhere(filters);\n    } else {\n      if (fieldPathOrFilter instanceof _Filter) {\n        // Standard Filter. Usual path.\n        opStr = fieldPathOrFilter.operator;\n        value = fieldPathOrFilter.value;\n        fieldPathOrFilter = fieldPathOrFilter.fieldPath;\n      }\n      let path;\n\n      if (isString(fieldPathOrFilter)) {\n        try {\n          path = fromDotSeparatedString(fieldPathOrFilter);\n        } catch (e) {\n          throw new Error(`firebase.firestore().collection().where(*) 'fieldPath' ${e.message}.`);\n        }\n      } else {\n        path = fieldPathOrFilter;\n      }\n\n      if (!this._modifiers.isValidOperator(opStr)) {\n        throw new Error(\n          \"firebase.firestore().collection().where(_, *) 'opStr' is invalid. Expected one of '==', '>', '>=', '<', '<=', '!=', 'array-contains', 'not-in', 'array-contains-any' or 'in'.\",\n        );\n      }\n\n      if (isUndefined(value)) {\n        throw new Error(\n          \"firebase.firestore().collection().where(_, _, *) 'value' argument expected.\",\n        );\n      }\n\n      if (\n        isNull(value) &&\n        !this._modifiers.isEqualOperator(opStr) &&\n        !this._modifiers.isNotEqualOperator(opStr)\n      ) {\n        throw new Error(\n          \"firebase.firestore().collection().where(_, _, *) 'value' is invalid. You can only perform equals comparisons on null\",\n        );\n      }\n\n      if (this._modifiers.isInOperator(opStr)) {\n        if (!isArray(value) || !value.length) {\n          throw new Error(\n            `firebase.firestore().collection().where(_, _, *) 'value' is invalid. A non-empty array is required for '${opStr}' filters.`,\n          );\n        }\n\n        if (value.length > 30) {\n          throw new Error(\n            `firebase.firestore().collection().where(_, _, *) 'value' is invalid. '${opStr}' filters support a maximum of 30 elements in the value array.`,\n          );\n        }\n      }\n\n      modifiers = this._modifiers._copy().where(path, opStr, value);\n    }\n\n    try {\n      modifiers.validateWhere();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().where() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}